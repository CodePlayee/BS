{"queryPath":"/src/River.js","absPath":"/Users/gaozhen/Documents/BS/src/River.js","realPath":"/src/River.js","type":"script","source":"const d3 = require(\"d3\");\nconst Bezier = require('bezier-js')\nconst { recursiveSubdivision } = require(\"./noisyEdge.js\");\nconst { utils } = require('./utils')\nconst { drawPt } = require('./draw')\nconst Point = require('./Point')\n\nconst seed = 4; //used to product random numbers\nconst randInt = utils.makeRandInt(seed); // random int maker\n\nconst branchAndMainstreamLenScale = 1.6 //支流总长度与干流总长度的比值\nconst defaultMsHeadLenRatio = 0.3 //干流开头一段河流长度与支流总长度的比值\nconst lenTolerate = 10 //曲线长度允许的误差范围\n\nclass River {\n\t/**\n\t * \n\t * @param {River} parent \n\t * @param {Point} source 河源点\n\t * @param {Point} target 河口点\n\t * @param {object} properties 原始信息\n\t */\n\tconstructor(parent, source, target, properties) {\n\t\t// this.id=id //后续可能还需要 id 属性\n\t\tthis.parent = parent //该河流汇入的上级河流，最高级干流的 parent 为空\n\t\tthis.children = undefined //该河流的支流\n\t\tthis.properties = properties //原始语义信息\n\n\t\tthis.ration = properties && properties.ration // 当前节点量化值\n\t\tthis.subsRation = properties && properties.subsRation // 当前节点的子节点量化值总和\n\n\t\tthis.msHeadLen = undefined // 该河流作为干流时，其源头一段（与其支流表达作用类似）的长度\n\t\tthis.setCurveLen = undefined // 河流的设定长度，在河流生成之前已按比例计算设定\n\t\tthis.strightLen = undefined //河源到河口的图面直线距离\n\t\tthis.source = source\n\t\tthis.target = target\n\n\t\t// 以下数据可变\n\t\tthis.varLinePts = undefined //折线上的点集合\n\t\tthis.bezier = undefined //贝塞尔曲线\n\t\tthis.bezierPts = undefined // 贝塞尔曲线上的点集合\n\t\tthis.riverPts = undefined //光滑处理后的线上点集合\n\n\t\tthis.branchMergePts = undefined // 干流上各支流汇入点 {pt:点,i:在0~1之间的 this.bezier 取点参数}\n\t}\n\n\t// 获取当前河流的层级\n\tgetLevel() {\n\t\tlet parent = this.parent\n\t\tlet level = 0\n\t\twhile (parent) {\n\t\t\tparent = parent.parent\n\t\t\tlevel++\n\t\t}\n\t\treturn level\n\t}\n\n\t// 设置河源\n\tsetSource(pt) {\n\t\tthis.source = pt\n\t}\n\n\t// 设置河口\n\tsetTarget(pt) {\n\t\tthis.target = pt\n\t}\n\n\t/**\n\t * 在起点未知的情况下，为该河流找到了合适的贝塞尔曲线并设置\n\t * @param {Bezier} bezier \n\t * @param {Number} steps 贝塞尔曲线上内插的点数量\n\t */\n\tsetBezier(bezier, steps) {\n\t\tconst { 0: source } = bezier.points\n\t\tthis.setSource(new Point(source.x, source.y))\n\t\tthis.bezier = bezier\n\t\tthis.bezierPts = this.bezier.getLUT(steps)\n\t}\n\n\t/**\n\t * 已确定起止点，由两个控制点生成贝塞尔曲线并获取线上中间点集合\n\t * @param {Point} sCtrlPt \n\t * @param {Point} tCtrlPt \n\t * @param {number} steps \n\t */\n\tsetBezierByCtrlPts(sCtrlPt, tCtrlPt, steps) {\n\t\t/**\n\t\t *      sCtrlPt       tCtrlPt\n\t\t * \n\t\t * \tsource\t\t\t\t\t\t\t\t\t\t\t\ttarget\n\t\t */\n\t\tconst bezier = new Bezier(this.source, sCtrlPt, tCtrlPt, this.target)\n\n\t\tthis.bezier = bezier\n\t\tthis.bezierPts = this.bezier.getLUT(steps)\n\t\treturn bezier\n\t}\n\n\t// 设置该河流的支流\n\tsetBranches(branches) {\n\t\tthis.children = branches\n\t}\n\n\t// 获取河流图面符号长度\n\t// 暂时按贝塞尔曲线长度计算\n\tgetCurveLen() {\n\t\treturn this.bezier.length()\n\t}\n\n\t// 计算并设定各支流的曲线长度(在生成支流之前)\n\tsetBranchCurveLen() {\n\t\t//支流总的曲线长度\n\t\tconst branchCurveLenSum = this.setCurveLen * branchAndMainstreamLenScale\n\t\tthis.msHeadLen = this.ration ? this.ration / this.subsRation * branchCurveLenSum\n\t\t\t: defaultMsHeadLenRatio * branchCurveLenSum\n\t\tthis.children.forEach(branch => {\n\t\t\tbranch.setCurveLen = (branch.ration + branch.subsRation) / this.subsRation * branchCurveLenSum\n\t\t})\n\t}\n\n\t// 按固定数量间隔获取贝塞尔曲线上的构成点，作为各支流的汇入点（河口），适用于顶级干流\n\t// 注意：尽管干流源头一段（msHead）与支流(branch[i])之间的长度比等于其量化数值比，\n\t// 但是 msHead、支流与干流上其他部分的长度不满足这样的比例关系，原因在于支流总长度不等于干流长度.\n\tcalcBranchMergePts() {\n\t\tif (!this.bezier) return console.error('bezier of the river must be generated before calMergePts.')\n\t\tif (!this.children) return console.error('the children of this river is undefined.')\n\n\t\tconst branchCount = this.children.length\n\t\tconst { bezierPts } = this\n\t\tconst msPtCount = bezierPts.length\n\t\tlet mergePts = []\n\n\t\tthis.setBranchCurveLen()\n\n\t\tlet msHeadPt\n\t\tlet curLen = this.bezier.split(0, 0.1).length()\n\t\tlet i = Math.round(msPtCount * 0.1)\n\t\t// 通过长度确定第一个支流汇入点(干流上 0.1 到 0.5 点位处)\n\t\tfor (; i < msPtCount * 0.5; i++) {\n\t\t\tcurLen += utils.twoPointsDistance(bezierPts[i - 1], bezierPts[i])\n\t\t\tif (Math.abs(curLen - this.msHeadLen) < lenTolerate) {\n\t\t\t\tmsHeadPt = bezierPts[i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tcurLen = 0\n\t\t// 剩下的支流汇入点在第一个支流汇入点和河口之间按长度均匀分段获取\n\t\tconst segLen = (this.setCurveLen - this.msHeadLen) / branchCount\n\t\tfor (let j = msPtCount - 2; j > -1; j--) {\n\t\t\tcurLen += utils.twoPointsDistance(bezierPts[j], bezierPts[j + 1])\n\t\t\tif (Math.abs(curLen - segLen) < 10) {\n\t\t\t\tmergePts.unshift(bezierPts[j])\n\t\t\t\tcurLen = 0\n\t\t\t\tif (mergePts.length + 1 === branchCount) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmergePts.unshift(msHeadPt)\n\n\t\t// 最终转换为由 Bezier.get(t) 方法获得的点({pt:点,i:在 0~1之间的参数})\n\t\tmergePts = mergePts.map(pt => pt2i(this.bezier, pt))\n\t\tthis.branchMergePts = mergePts\n\t\treturn mergePts\n\t}\n\n\t// 利用 noisyEdge 生成折线上的点集合\n\tgenVarlinePts(options) {\n\t\tconst { minLen, amplitude, x0, y0, x1, y1, x2, y2, x3, y3 } = options;\n\t\tconst getVarlinePts = recursiveSubdivision(minLen, amplitude, randInt);\n\t\tconst startPt = [x0, y0];\n\t\tconst endPt = [x1, y1];\n\t\tconst topPt = [x2, y2];\n\t\tconst bottomPt = [x3, y3];\n\n\t\tconst ptsInVarline = getVarlinePts(startPt, endPt, topPt, bottomPt);\n\t\tthis.varLinePts = [startPt, ...ptsInVarline]\n\t\treturn this.varLinePts;\n\t}\n\n\t//计算河源到河口的图面直线距离\n\tcalcStrightLen() {\n\t\tconst { source, target } = this\n\t\tif (source && target) {\n\t\t\tconst dx = source.x - target.x\n\t\t\tconst dy = source.y - target.y\n\t\t\treturn this.strightLen = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2))\n\t\t}\n\t\tconsole.error('unvalid source and target in calStrightLen!')\n\t}\n\n\t/**\n\t * 绘制单线河\n\t * @param {[]} pts 代表河流的线上的点\n\t * @param {string} id 河流id\n\t * @param {string} color \n\t * @param {string} containerId 容器id\n\t */\n\tdraw(pts, id, color = 'blue', linewidth = 1, containerId) {\n\t\tconst pathGen = d3.path();\n\t\tif (pts[0].x || pts[0].x === 0) {\n\t\t\tpathGen.moveTo(pts[0].x, pts[0].y);\n\t\t\tpts.forEach(pt => {\n\t\t\t\tpathGen.lineTo(pt.x, pt.y);\n\t\t\t});\n\t\t} else if (pts[0][0] || pts[0][0] === 0) {\n\t\t\tpathGen.moveTo(pts[0][0], pts[0][1]);\n\t\t\tpts.forEach(pt => {\n\t\t\t\tpathGen.lineTo(pt[0], pt[1]);\n\t\t\t});\n\t\t}\n\n\t\tlet container;\n\t\tif (containerId) {\n\t\t\tcontainer = d3.select(`#${containerId}`);\n\t\t} else {\n\t\t\tcontainer = d3.select('svg');\n\t\t}\n\n\t\tlet path = container.select(`#${id}`);\n\t\tpath.remove();\n\t\tcontainer\n\t\t\t.append(\"path\")\n\t\t\t.style(\"stroke\", color)\n\t\t\t.style('stroke-width', linewidth)\n\t\t\t.style(\"fill\", \"none\")\n\t\t\t.attr(\"d\", pathGen)\n\t\t\t.attr(\"id\", () => id);\n\t}\n}\n\n// 由贝塞尔曲线上的点的坐标确定其 i 值\nfunction pt2i(bezier, pt) {\n\tlet curPt\n\tfor (let i = 0.01; i < 1.0; i += 0.01) {\n\t\tcurPt = bezier.get(i)\n\t\tif (Math.pow(curPt.x - pt.x, 2) + Math.pow(curPt.y - pt.y, 2) < 10) {\n\t\t\treturn { pt: curPt, iValue: +i.toFixed(4) }\n\t\t}\n\t}\n}\n\nmodule.exports = { River }","code":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar d3 = require(\"d3\");\nvar Bezier = require('bezier-js');\n\nvar _require = require(\"./noisyEdge.js\"),\n    recursiveSubdivision = _require.recursiveSubdivision;\n\nvar _require2 = require('./utils'),\n    utils = _require2.utils;\n\nvar _require3 = require('./draw'),\n    drawPt = _require3.drawPt;\n\nvar Point = require('./Point');\n\nvar seed = 4;\nvar randInt = utils.makeRandInt(seed);\n\nvar branchAndMainstreamLenScale = 1.6;\nvar defaultMsHeadLenRatio = 0.3;\nvar lenTolerate = 10;\nvar River = function () {\n\tfunction River(parent, source, target, properties) {\n\t\t_classCallCheck(this, River);\n\n\t\tthis.parent = parent;\n\t\tthis.children = undefined;\n\t\tthis.properties = properties;\n\n\t\tthis.ration = properties && properties.ration;\n\t\tthis.subsRation = properties && properties.subsRation;\n\n\t\tthis.msHeadLen = undefined;\n\t\tthis.setCurveLen = undefined;\n\t\tthis.strightLen = undefined;\n\t\tthis.source = source;\n\t\tthis.target = target;\n\n\t\tthis.varLinePts = undefined;\n\t\tthis.bezier = undefined;\n\t\tthis.bezierPts = undefined;\n\t\tthis.riverPts = undefined;\n\n\t\tthis.branchMergePts = undefined;\n\t}\n\n\t_createClass(River, [{\n\t\tkey: \"getLevel\",\n\t\tvalue: function getLevel() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar level = 0;\n\t\t\twhile (parent) {\n\t\t\t\tparent = parent.parent;\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\treturn level;\n\t\t}\n\t}, {\n\t\tkey: \"setSource\",\n\t\tvalue: function setSource(pt) {\n\t\t\tthis.source = pt;\n\t\t}\n\t}, {\n\t\tkey: \"setTarget\",\n\t\tvalue: function setTarget(pt) {\n\t\t\tthis.target = pt;\n\t\t}\n\t}, {\n\t\tkey: \"setBezier\",\n\t\tvalue: function setBezier(bezier, steps) {\n\t\t\tvar source = bezier.points[0];\n\n\t\t\tthis.setSource(new Point(source.x, source.y));\n\t\t\tthis.bezier = bezier;\n\t\t\tthis.bezierPts = this.bezier.getLUT(steps);\n\t\t}\n\t}, {\n\t\tkey: \"setBezierByCtrlPts\",\n\t\tvalue: function setBezierByCtrlPts(sCtrlPt, tCtrlPt, steps) {\n\t\t\tvar bezier = new Bezier(this.source, sCtrlPt, tCtrlPt, this.target);\n\n\t\t\tthis.bezier = bezier;\n\t\t\tthis.bezierPts = this.bezier.getLUT(steps);\n\t\t\treturn bezier;\n\t\t}\n\t}, {\n\t\tkey: \"setBranches\",\n\t\tvalue: function setBranches(branches) {\n\t\t\tthis.children = branches;\n\t\t}\n\t}, {\n\t\tkey: \"getCurveLen\",\n\t\tvalue: function getCurveLen() {\n\t\t\treturn this.bezier.length();\n\t\t}\n\t}, {\n\t\tkey: \"setBranchCurveLen\",\n\t\tvalue: function setBranchCurveLen() {\n\t\t\tvar _this = this;\n\n\t\t\tvar branchCurveLenSum = this.setCurveLen * branchAndMainstreamLenScale;\n\t\t\tthis.msHeadLen = this.ration ? this.ration / this.subsRation * branchCurveLenSum : defaultMsHeadLenRatio * branchCurveLenSum;\n\t\t\tthis.children.forEach(function (branch) {\n\t\t\t\tbranch.setCurveLen = (branch.ration + branch.subsRation) / _this.subsRation * branchCurveLenSum;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"calcBranchMergePts\",\n\t\tvalue: function calcBranchMergePts() {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (!this.bezier) return console.error('bezier of the river must be generated before calMergePts.');\n\t\t\tif (!this.children) return console.error('the children of this river is undefined.');\n\n\t\t\tvar branchCount = this.children.length;\n\t\t\tvar bezierPts = this.bezierPts;\n\n\t\t\tvar msPtCount = bezierPts.length;\n\t\t\tvar mergePts = [];\n\n\t\t\tthis.setBranchCurveLen();\n\n\t\t\tvar msHeadPt = void 0;\n\t\t\tvar curLen = this.bezier.split(0, 0.1).length();\n\t\t\tvar i = Math.round(msPtCount * 0.1);\n\n\t\t\tfor (; i < msPtCount * 0.5; i++) {\n\t\t\t\tcurLen += utils.twoPointsDistance(bezierPts[i - 1], bezierPts[i]);\n\t\t\t\tif (Math.abs(curLen - this.msHeadLen) < lenTolerate) {\n\t\t\t\t\tmsHeadPt = bezierPts[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurLen = 0;\n\n\t\t\tvar segLen = (this.setCurveLen - this.msHeadLen) / branchCount;\n\t\t\tfor (var j = msPtCount - 2; j > -1; j--) {\n\t\t\t\tcurLen += utils.twoPointsDistance(bezierPts[j], bezierPts[j + 1]);\n\t\t\t\tif (Math.abs(curLen - segLen) < 10) {\n\t\t\t\t\tmergePts.unshift(bezierPts[j]);\n\t\t\t\t\tcurLen = 0;\n\t\t\t\t\tif (mergePts.length + 1 === branchCount) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmergePts.unshift(msHeadPt);\n\n\t\t\tmergePts = mergePts.map(function (pt) {\n\t\t\t\treturn pt2i(_this2.bezier, pt);\n\t\t\t});\n\t\t\tthis.branchMergePts = mergePts;\n\t\t\treturn mergePts;\n\t\t}\n\t}, {\n\t\tkey: \"genVarlinePts\",\n\t\tvalue: function genVarlinePts(options) {\n\t\t\tvar minLen = options.minLen,\n\t\t\t    amplitude = options.amplitude,\n\t\t\t    x0 = options.x0,\n\t\t\t    y0 = options.y0,\n\t\t\t    x1 = options.x1,\n\t\t\t    y1 = options.y1,\n\t\t\t    x2 = options.x2,\n\t\t\t    y2 = options.y2,\n\t\t\t    x3 = options.x3,\n\t\t\t    y3 = options.y3;\n\n\t\t\tvar getVarlinePts = recursiveSubdivision(minLen, amplitude, randInt);\n\t\t\tvar startPt = [x0, y0];\n\t\t\tvar endPt = [x1, y1];\n\t\t\tvar topPt = [x2, y2];\n\t\t\tvar bottomPt = [x3, y3];\n\n\t\t\tvar ptsInVarline = getVarlinePts(startPt, endPt, topPt, bottomPt);\n\t\t\tthis.varLinePts = [startPt].concat(_toConsumableArray(ptsInVarline));\n\t\t\treturn this.varLinePts;\n\t\t}\n\t}, {\n\t\tkey: \"calcStrightLen\",\n\t\tvalue: function calcStrightLen() {\n\t\t\tvar source = this.source,\n\t\t\t    target = this.target;\n\n\t\t\tif (source && target) {\n\t\t\t\tvar dx = source.x - target.x;\n\t\t\t\tvar dy = source.y - target.y;\n\t\t\t\treturn this.strightLen = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n\t\t\t}\n\t\t\tconsole.error('unvalid source and target in calStrightLen!');\n\t\t}\n\t}, {\n\t\tkey: \"draw\",\n\t\tvalue: function draw(pts, id) {\n\t\t\tvar color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'blue';\n\t\t\tvar linewidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\t\t\tvar containerId = arguments[4];\n\n\t\t\tvar pathGen = d3.path();\n\t\t\tif (pts[0].x || pts[0].x === 0) {\n\t\t\t\tpathGen.moveTo(pts[0].x, pts[0].y);\n\t\t\t\tpts.forEach(function (pt) {\n\t\t\t\t\tpathGen.lineTo(pt.x, pt.y);\n\t\t\t\t});\n\t\t\t} else if (pts[0][0] || pts[0][0] === 0) {\n\t\t\t\tpathGen.moveTo(pts[0][0], pts[0][1]);\n\t\t\t\tpts.forEach(function (pt) {\n\t\t\t\t\tpathGen.lineTo(pt[0], pt[1]);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar container = void 0;\n\t\t\tif (containerId) {\n\t\t\t\tcontainer = d3.select(\"#\" + containerId);\n\t\t\t} else {\n\t\t\t\tcontainer = d3.select('svg');\n\t\t\t}\n\n\t\t\tvar path = container.select(\"#\" + id);\n\t\t\tpath.remove();\n\t\t\tcontainer.append(\"path\").style(\"stroke\", color).style('stroke-width', linewidth).style(\"fill\", \"none\").attr(\"d\", pathGen).attr(\"id\", function () {\n\t\t\t\treturn id;\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn River;\n}();\n\nfunction pt2i(bezier, pt) {\n\tvar curPt = void 0;\n\tfor (var i = 0.01; i < 1.0; i += 0.01) {\n\t\tcurPt = bezier.get(i);\n\t\tif (Math.pow(curPt.x - pt.x, 2) + Math.pow(curPt.y - pt.y, 2) < 10) {\n\t\t\treturn { pt: curPt, iValue: +i.toFixed(4) };\n\t\t}\n\t}\n}\n\nmodule.exports = { River: River };","codeWraped":"Cube(\"/src/River.js\", [\"/node_modules/d3/dist/d3.node.js\", \"/node_modules/bezier-js/index.js\", \"/src/noisyEdge.js\", \"/src/utils.js\", \"/src/draw.js\", \"/src/Point.js\"], function (module, exports, require, load, process, global) {\n\n  var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n  function _toConsumableArray(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;} else {return Array.from(arr);}}\n\n  function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n  var d3 = require('/node_modules/d3/dist/d3.node.js');\n  var Bezier = require('/node_modules/bezier-js/index.js');\n\n  var _require = require('/src/noisyEdge.js'),\n  recursiveSubdivision = _require.recursiveSubdivision;\n\n  var _require2 = require('/src/utils.js'),\n  utils = _require2.utils;\n\n  var _require3 = require('/src/draw.js'),\n  drawPt = _require3.drawPt;\n\n  var Point = require('/src/Point.js');\n\n  var seed = 4;\n  var randInt = utils.makeRandInt(seed);\n\n  var branchAndMainstreamLenScale = 1.6;\n  var defaultMsHeadLenRatio = 0.3;\n  var lenTolerate = 10;\n  var River = function () {\n    function River(parent, source, target, properties) {\n      _classCallCheck(this, River);\n\n      this.parent = parent;\n      this.children = undefined;\n      this.properties = properties;\n\n      this.ration = properties && properties.ration;\n      this.subsRation = properties && properties.subsRation;\n\n      this.msHeadLen = undefined;\n      this.setCurveLen = undefined;\n      this.strightLen = undefined;\n      this.source = source;\n      this.target = target;\n\n      this.varLinePts = undefined;\n      this.bezier = undefined;\n      this.bezierPts = undefined;\n      this.riverPts = undefined;\n\n      this.branchMergePts = undefined;\n    }\n\n    _createClass(River, [{\n      key: \"getLevel\",\n      value: function getLevel() {\n        var parent = this.parent;\n        var level = 0;\n        while (parent) {\n          parent = parent.parent;\n          level++;\n        }\n        return level;\n      } },\n    {\n      key: \"setSource\",\n      value: function setSource(pt) {\n        this.source = pt;\n      } },\n    {\n      key: \"setTarget\",\n      value: function setTarget(pt) {\n        this.target = pt;\n      } },\n    {\n      key: \"setBezier\",\n      value: function setBezier(bezier, steps) {\n        var source = bezier.points[0];\n\n        this.setSource(new Point(source.x, source.y));\n        this.bezier = bezier;\n        this.bezierPts = this.bezier.getLUT(steps);\n      } },\n    {\n      key: \"setBezierByCtrlPts\",\n      value: function setBezierByCtrlPts(sCtrlPt, tCtrlPt, steps) {\n        var bezier = new Bezier(this.source, sCtrlPt, tCtrlPt, this.target);\n\n        this.bezier = bezier;\n        this.bezierPts = this.bezier.getLUT(steps);\n        return bezier;\n      } },\n    {\n      key: \"setBranches\",\n      value: function setBranches(branches) {\n        this.children = branches;\n      } },\n    {\n      key: \"getCurveLen\",\n      value: function getCurveLen() {\n        return this.bezier.length();\n      } },\n    {\n      key: \"setBranchCurveLen\",\n      value: function setBranchCurveLen() {\n        var _this = this;\n\n        var branchCurveLenSum = this.setCurveLen * branchAndMainstreamLenScale;\n        this.msHeadLen = this.ration ? this.ration / this.subsRation * branchCurveLenSum : defaultMsHeadLenRatio * branchCurveLenSum;\n        this.children.forEach(function (branch) {\n          branch.setCurveLen = (branch.ration + branch.subsRation) / _this.subsRation * branchCurveLenSum;\n        });\n      } },\n    {\n      key: \"calcBranchMergePts\",\n      value: function calcBranchMergePts() {\n        var _this2 = this;\n\n        if (!this.bezier) return console.error('bezier of the river must be generated before calMergePts.');\n        if (!this.children) return console.error('the children of this river is undefined.');\n\n        var branchCount = this.children.length;\n        var bezierPts = this.bezierPts;\n\n        var msPtCount = bezierPts.length;\n        var mergePts = [];\n\n        this.setBranchCurveLen();\n\n        var msHeadPt = void 0;\n        var curLen = this.bezier.split(0, 0.1).length();\n        var i = Math.round(msPtCount * 0.1);\n\n        for (; i < msPtCount * 0.5; i++) {\n          curLen += utils.twoPointsDistance(bezierPts[i - 1], bezierPts[i]);\n          if (Math.abs(curLen - this.msHeadLen) < lenTolerate) {\n            msHeadPt = bezierPts[i];\n            break;\n          }\n        }\n\n        curLen = 0;\n\n        var segLen = (this.setCurveLen - this.msHeadLen) / branchCount;\n        for (var j = msPtCount - 2; j > -1; j--) {\n          curLen += utils.twoPointsDistance(bezierPts[j], bezierPts[j + 1]);\n          if (Math.abs(curLen - segLen) < 10) {\n            mergePts.unshift(bezierPts[j]);\n            curLen = 0;\n            if (mergePts.length + 1 === branchCount) {\n              break;\n            }\n          }\n        }\n        mergePts.unshift(msHeadPt);\n\n        mergePts = mergePts.map(function (pt) {\n          return pt2i(_this2.bezier, pt);\n        });\n        this.branchMergePts = mergePts;\n        return mergePts;\n      } },\n    {\n      key: \"genVarlinePts\",\n      value: function genVarlinePts(options) {\n        var minLen = options.minLen,\n        amplitude = options.amplitude,\n        x0 = options.x0,\n        y0 = options.y0,\n        x1 = options.x1,\n        y1 = options.y1,\n        x2 = options.x2,\n        y2 = options.y2,\n        x3 = options.x3,\n        y3 = options.y3;\n\n        var getVarlinePts = recursiveSubdivision(minLen, amplitude, randInt);\n        var startPt = [x0, y0];\n        var endPt = [x1, y1];\n        var topPt = [x2, y2];\n        var bottomPt = [x3, y3];\n\n        var ptsInVarline = getVarlinePts(startPt, endPt, topPt, bottomPt);\n        this.varLinePts = [startPt].concat(_toConsumableArray(ptsInVarline));\n        return this.varLinePts;\n      } },\n    {\n      key: \"calcStrightLen\",\n      value: function calcStrightLen() {\n        var source = this.source,\n        target = this.target;\n\n        if (source && target) {\n          var dx = source.x - target.x;\n          var dy = source.y - target.y;\n          return this.strightLen = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n        }\n        console.error('unvalid source and target in calStrightLen!');\n      } },\n    {\n      key: \"draw\",\n      value: function draw(pts, id) {\n        var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'blue';\n        var linewidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n        var containerId = arguments[4];\n\n        var pathGen = d3.path();\n        if (pts[0].x || pts[0].x === 0) {\n          pathGen.moveTo(pts[0].x, pts[0].y);\n          pts.forEach(function (pt) {\n            pathGen.lineTo(pt.x, pt.y);\n          });\n        } else if (pts[0][0] || pts[0][0] === 0) {\n          pathGen.moveTo(pts[0][0], pts[0][1]);\n          pts.forEach(function (pt) {\n            pathGen.lineTo(pt[0], pt[1]);\n          });\n        }\n\n        var container = void 0;\n        if (containerId) {\n          container = d3.select(\"#\" + containerId);\n        } else {\n          container = d3.select('svg');\n        }\n\n        var path = container.select(\"#\" + id);\n        path.remove();\n        container.append(\"path\").style(\"stroke\", color).style('stroke-width', linewidth).style(\"fill\", \"none\").attr(\"d\", pathGen).attr(\"id\", function () {\n          return id;\n        });\n      } }]);\n\n\n    return River;\n  }();\n\n  function pt2i(bezier, pt) {\n    var curPt = void 0;\n    for (var i = 0.01; i < 1.0; i += 0.01) {\n      curPt = bezier.get(i);\n      if (Math.pow(curPt.x - pt.x, 2) + Math.pow(curPt.y - pt.y, 2) < 10) {\n        return { pt: curPt, iValue: +i.toFixed(4) };\n      }\n    }\n  }\n\n  module.exports = { River: River };return module.exports;});","sourceMap":null,"modifyTime":1583311600233,"mime":"application/javascript","wrap":true,"skip":false,"compress":false,"ext":".js","targetExt":".js","loads":[],"originalLoads":[],"requires":["/node_modules/d3/dist/d3.node.js","/node_modules/bezier-js/index.js","/src/noisyEdge.js","/src/utils.js","/src/draw.js","/src/Point.js"],"requiresOrigin":["/node_modules/d3/dist/d3.node.js","/node_modules/bezier-js/index.js","/src/noisyEdge.js","/src/utils.js","/src/draw.js","/src/Point.js"],"debugInfo":[],"requiresArgsRefer":[{"type":"StringLiteral","start":950,"end":954,"loc":{"start":{"line":9,"column":17},"end":{"line":9,"column":21}},"extra":{"rawValue":"d3","raw":"\"d3\""},"value":"/node_modules/d3/dist/d3.node.js"},{"type":"StringLiteral","start":978,"end":989,"loc":{"start":{"line":10,"column":21},"end":{"line":10,"column":32}},"extra":{"rawValue":"bezier-js","raw":"'bezier-js'"},"value":"/node_modules/bezier-js/index.js"},{"type":"StringLiteral","start":1016,"end":1032,"loc":{"start":{"line":12,"column":23},"end":{"line":12,"column":39}},"extra":{"rawValue":"./noisyEdge.js","raw":"\"./noisyEdge.js\""},"value":"/src/noisyEdge.js"},{"type":"StringLiteral","start":1118,"end":1127,"loc":{"start":{"line":15,"column":24},"end":{"line":15,"column":33}},"extra":{"rawValue":"./utils","raw":"'./utils'"},"value":"/src/utils.js"},{"type":"StringLiteral","start":1184,"end":1192,"loc":{"start":{"line":18,"column":24},"end":{"line":18,"column":32}},"extra":{"rawValue":"./draw","raw":"'./draw'"},"value":"/src/draw.js"},{"type":"StringLiteral","start":1247,"end":1256,"loc":{"start":{"line":21,"column":20},"end":{"line":21,"column":29}},"extra":{"rawValue":"./Point","raw":"'./Point'"},"value":"/src/Point.js"}]}