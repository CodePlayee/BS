{"queryPath":"/src/utils.js","absPath":"/Users/gaozhen/Documents/BS/src/utils.js","realPath":"/src/utils.js","type":"script","source":"/* 32-bit LCG random number function -- see http://www.firstpr.com.au/dsp/rand31/\n * for a great discussion of optimizations, none of which I need here\n *\n *    - Start with a seed\n *    - Each step, mutate seed\n *    - 0 < seed < wrap\n *    - to get integer random 0 <= x < N, use mod N\n *    - to get float random 0.0 <= x < 1.0, divide by range (wrap-1)\n *\n * This code is very simple, and the sequence of random numbers is reasonable\n * for a given seed, but the sequences for related seeds are related.\n */\n\n// TODO: see https://github.com/nquinlan/better-random-numbers-for-javascript-mirror#license\n\nfunction makeRand(seed) {\n    const multiplier = 47271;\n    const wrap = 0x7fffffff;\n    seed = seed % wrap;\n    if (typeof seed != \"number\" || !(seed > 0)) throw \"check seed to makeRandInt\";\n    return function () {\n        seed = (seed * multiplier) % wrap;\n        return seed;\n    };\n}\n\n//product predictable random integer number x(0<=x<N)\nfunction makeRandInt(seed) {\n    let generator = makeRand(seed);\n    return N => generator() % N;\n}\n\nfunction makeRandFloat(seed) {\n    const wrap = 0x7fffffff;\n    let generator = makeRand(seed);\n    return () => (generator() - 1.0) / (wrap - 1.0);\n}\n\n//两点之间的欧氏距离\nfunction twoPointsDistance(startPt, endPt) {\n    let dx, dy;\n    if (startPt.x || startPt.x === 0) {\n        dx = startPt.x - endPt.x;\n        dy = startPt.y - endPt.y;\n    } else if (startPt[0] || startPt[0] === 0) {\n        dx = startPt[0] - endPt[0];\n        dy = startPt[1] - endPt[1];\n    }\n    return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n}\n\n//一点到直线（由两点确定）之间的距离\nfunction pointToLineDistance(startPt, endPt, pt) {\n    const A = endPt.y - startPt.y;\n    const B = startPt.x - endPt.x;\n    const C = endPt.x * startPt.y - startPt.x * endPt.y;\n    const denominator = Math.sqrt(A * A + B * B);\n    if (denominator === 0) {\n        console.error(\"unvalid line.\");\n        return;\n    }\n    return Math.sqrt((A * pt.x + B * pt.y + C) / denominator);\n}\n\n//计算两个向量之间的夹角 v1:[x1,y1],v2:[x2,y2]\nfunction calVectorsAngle(v1, v2) {\n    let vecMulti, scale\n    if (v1.x || v1.x === 0) {\n        vecMulti = v1.x * v2.x + v1.y * v2.y;\n        scale =\n            Math.sqrt(v1.x * v1.x + v1.y * v1.y) *\n            Math.sqrt(v2.x * v2.x + v2.y * v2.y);\n    } else {\n        vecMulti = v1[0] * v2[0] + v1[1] * v2[1];\n        scale =\n            Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]) *\n            Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\n    }\n\n    return Number(Math.acos(vecMulti / scale).toFixed(2));\n}\n\n//围绕两点连线中点，将两线逆时针旋转theta角度，求旋转后的两点\nfunction calQuadPts(p1, p2, theta) {\n    const dis = twoPointsDistance(p1, p2);\n    const centerX = p1.x + (p2.x - p1.x) * 0.5;\n    const centerY = p1.y + (p2.y - p1.y) * 0.5;\n    const _p1 = [p1.x - centerX, p1.y - centerY];\n    const rotatedP1 = [\n        _p1[0] * Math.cos(theta) - _p1[1] * Math.sin(theta),\n        _p1[1] * Math.cos(theta) + _p1[0] * Math.sin(theta)\n    ];\n\n    const _p2 = [p2.x - centerX, p2.y - centerY];\n    const rotatedP2 = [\n        _p2[0] * Math.cos(theta) - _p2[1] * Math.sin(theta),\n        _p2[1] * Math.cos(theta) + _p2[0] * Math.sin(theta)\n    ];\n\n    return [\n        [rotatedP1[0] + centerX, rotatedP1[1] + centerY],\n        [rotatedP2[0] + centerX, rotatedP2[1] + centerY]\n    ];\n}\n\nconst utils = {\n    makeRandInt,\n    makeRandFloat,\n    twoPointsDistance,\n    pointToLineDistance,\n    calVectorsAngle,\n    calQuadPts\n};\n\nmodule.exports = { utils };\n","code":"\"use strict\";\n\nfunction makeRand(seed) {\n    var multiplier = 47271;\n    var wrap = 0x7fffffff;\n    seed = seed % wrap;\n    if (typeof seed != \"number\" || !(seed > 0)) throw \"check seed to makeRandInt\";\n    return function () {\n        seed = seed * multiplier % wrap;\n        return seed;\n    };\n}\n\nfunction makeRandInt(seed) {\n    var generator = makeRand(seed);\n    return function (N) {\n        return generator() % N;\n    };\n}\n\nfunction makeRandFloat(seed) {\n    var wrap = 0x7fffffff;\n    var generator = makeRand(seed);\n    return function () {\n        return (generator() - 1.0) / (wrap - 1.0);\n    };\n}\n\nfunction twoPointsDistance(startPt, endPt) {\n    var dx = void 0,\n        dy = void 0;\n    if (startPt.x || startPt.x === 0) {\n        dx = startPt.x - endPt.x;\n        dy = startPt.y - endPt.y;\n    } else if (startPt[0] || startPt[0] === 0) {\n        dx = startPt[0] - endPt[0];\n        dy = startPt[1] - endPt[1];\n    }\n    return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n}\n\nfunction pointToLineDistance(startPt, endPt, pt) {\n    var A = endPt.y - startPt.y;\n    var B = startPt.x - endPt.x;\n    var C = endPt.x * startPt.y - startPt.x * endPt.y;\n    var denominator = Math.sqrt(A * A + B * B);\n    if (denominator === 0) {\n        console.error(\"unvalid line.\");\n        return;\n    }\n    return Math.sqrt((A * pt.x + B * pt.y + C) / denominator);\n}\n\nfunction calVectorsAngle(v1, v2) {\n    var vecMulti = void 0,\n        scale = void 0;\n    if (v1.x || v1.x === 0) {\n        vecMulti = v1.x * v2.x + v1.y * v2.y;\n        scale = Math.sqrt(v1.x * v1.x + v1.y * v1.y) * Math.sqrt(v2.x * v2.x + v2.y * v2.y);\n    } else {\n        vecMulti = v1[0] * v2[0] + v1[1] * v2[1];\n        scale = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]) * Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\n    }\n\n    return Number(Math.acos(vecMulti / scale).toFixed(2));\n}\n\nfunction calQuadPts(p1, p2, theta) {\n    var dis = twoPointsDistance(p1, p2);\n    var centerX = p1.x + (p2.x - p1.x) * 0.5;\n    var centerY = p1.y + (p2.y - p1.y) * 0.5;\n    var _p1 = [p1.x - centerX, p1.y - centerY];\n    var rotatedP1 = [_p1[0] * Math.cos(theta) - _p1[1] * Math.sin(theta), _p1[1] * Math.cos(theta) + _p1[0] * Math.sin(theta)];\n\n    var _p2 = [p2.x - centerX, p2.y - centerY];\n    var rotatedP2 = [_p2[0] * Math.cos(theta) - _p2[1] * Math.sin(theta), _p2[1] * Math.cos(theta) + _p2[0] * Math.sin(theta)];\n\n    return [[rotatedP1[0] + centerX, rotatedP1[1] + centerY], [rotatedP2[0] + centerX, rotatedP2[1] + centerY]];\n}\n\nvar utils = {\n    makeRandInt: makeRandInt,\n    makeRandFloat: makeRandFloat,\n    twoPointsDistance: twoPointsDistance,\n    pointToLineDistance: pointToLineDistance,\n    calVectorsAngle: calVectorsAngle,\n    calQuadPts: calQuadPts\n};\n\nmodule.exports = { utils: utils };","codeWraped":"Cube(\"/src/utils.js\", [], function (module, exports, require, load, process, global) {\n\n  function makeRand(seed) {\n    var multiplier = 47271;\n    var wrap = 0x7fffffff;\n    seed = seed % wrap;\n    if (typeof seed != \"number\" || !(seed > 0)) throw \"check seed to makeRandInt\";\n    return function () {\n      seed = seed * multiplier % wrap;\n      return seed;\n    };\n  }\n\n  function makeRandInt(seed) {\n    var generator = makeRand(seed);\n    return function (N) {\n      return generator() % N;\n    };\n  }\n\n  function makeRandFloat(seed) {\n    var wrap = 0x7fffffff;\n    var generator = makeRand(seed);\n    return function () {\n      return (generator() - 1.0) / (wrap - 1.0);\n    };\n  }\n\n  function twoPointsDistance(startPt, endPt) {\n    var dx = void 0,\n    dy = void 0;\n    if (startPt.x || startPt.x === 0) {\n      dx = startPt.x - endPt.x;\n      dy = startPt.y - endPt.y;\n    } else if (startPt[0] || startPt[0] === 0) {\n      dx = startPt[0] - endPt[0];\n      dy = startPt[1] - endPt[1];\n    }\n    return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n  }\n\n  function pointToLineDistance(startPt, endPt, pt) {\n    var A = endPt.y - startPt.y;\n    var B = startPt.x - endPt.x;\n    var C = endPt.x * startPt.y - startPt.x * endPt.y;\n    var denominator = Math.sqrt(A * A + B * B);\n    if (denominator === 0) {\n      console.error(\"unvalid line.\");\n      return;\n    }\n    return Math.sqrt((A * pt.x + B * pt.y + C) / denominator);\n  }\n\n  function calVectorsAngle(v1, v2) {\n    var vecMulti = void 0,\n    scale = void 0;\n    if (v1.x || v1.x === 0) {\n      vecMulti = v1.x * v2.x + v1.y * v2.y;\n      scale = Math.sqrt(v1.x * v1.x + v1.y * v1.y) * Math.sqrt(v2.x * v2.x + v2.y * v2.y);\n    } else {\n      vecMulti = v1[0] * v2[0] + v1[1] * v2[1];\n      scale = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]) * Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\n    }\n\n    return Number(Math.acos(vecMulti / scale).toFixed(2));\n  }\n\n  function calQuadPts(p1, p2, theta) {\n    var dis = twoPointsDistance(p1, p2);\n    var centerX = p1.x + (p2.x - p1.x) * 0.5;\n    var centerY = p1.y + (p2.y - p1.y) * 0.5;\n    var _p1 = [p1.x - centerX, p1.y - centerY];\n    var rotatedP1 = [_p1[0] * Math.cos(theta) - _p1[1] * Math.sin(theta), _p1[1] * Math.cos(theta) + _p1[0] * Math.sin(theta)];\n\n    var _p2 = [p2.x - centerX, p2.y - centerY];\n    var rotatedP2 = [_p2[0] * Math.cos(theta) - _p2[1] * Math.sin(theta), _p2[1] * Math.cos(theta) + _p2[0] * Math.sin(theta)];\n\n    return [[rotatedP1[0] + centerX, rotatedP1[1] + centerY], [rotatedP2[0] + centerX, rotatedP2[1] + centerY]];\n  }\n\n  var utils = {\n    makeRandInt: makeRandInt,\n    makeRandFloat: makeRandFloat,\n    twoPointsDistance: twoPointsDistance,\n    pointToLineDistance: pointToLineDistance,\n    calVectorsAngle: calVectorsAngle,\n    calQuadPts: calQuadPts };\n\n\n  module.exports = { utils: utils };return module.exports;});","sourceMap":null,"modifyTime":1583243400038,"mime":"application/javascript","wrap":true,"skip":false,"compress":false,"ext":".js","targetExt":".js","loads":[],"originalLoads":[],"requires":[],"requiresOrigin":[],"debugInfo":[],"requiresArgsRefer":[]}