{"queryPath":"/src/main.js","absPath":"/Users/gaozhen/Documents/BS/src/main.js","realPath":"/src/main.js","type":"script","source":"const { River } = require('./River')\nconst Point = require('./Point')\nconst { drawPt, drawLine } = require('./draw')\nconst Bezier = require('bezier-js')\nconst turf = require('@turf/turf')\nconst { utils } = require('./utils')\n\nconst sqrt2 = Math.sqrt(2)\nconst digitMatcher = /\\d+/\n\nconst lenTolerate = 10 //曲线长度允许的误差范围\nconst mbAngle = Math.PI / 3 //支流汇入干流的角度不大于 60°\nconst minMergeAngle = 10 // 支流汇入干流的最小角度\nconst stepAngle = 5 // 调整支流位置时每次绕汇入点旋转的角度\n\n\n// 构建顶级干流，由贝塞尔曲线生成\nfunction genMainStream(svg, padding, properties) {\n    let { width, height } = svg.style\n    width = +width.match(digitMatcher)[0] || 960\n    height = +height.match(digitMatcher)[0] || 600\n\n    const source = new Point(padding, height * 0.5)\n    const target = new Point(width - padding, height * 0.5)\n    const sCtrlPt = new Point(width * 0.5, height * 0.25)\n    const tCtrlPt = new Point(width * 0.5, height * 0.75)\n\n    const ms = new River(null, source, target, properties)\n    ms.setBezierByCtrlPts(sCtrlPt, tCtrlPt)\n    ms.setCurveLen = ms.bezier.length()\n\n    return ms\n}\n\n/**\n * \n * @param {River} parent 上级河流\n * @param {[]} data 上级河流的各支流原始数据\n */\nfunction genBranches(parent, data) {\n    const branchCount = data.length\n\n    let branch\n    const branches = [] // 未设置起止点和贝塞尔曲线的支流\n    const leftBranchesBeziers = [] // 干流左侧支流对应的贝塞尔曲线\n    const rightBranchesBeziers = [] // 干流右侧支流对应的贝塞尔曲线\n\n    for (let i = 0; i < branchCount; i++) {\n        branch = new River(parent, undefined, undefined, data[i])\n        branches.push(branch)\n    }\n\n    parent.setBranches(branches)\n\n    const branchMergePts = parent.calcBranchMergePts()\n    branches.forEach((branch, idx) => {\n        const { pt, iValue } = branchMergePts[idx]\n        // 1.确定各支流的汇入点（河口）\n        branch.setTarget(pt)\n        drawPt(branch.target)\n\n        // 2.对于各支流，生成满足设定长度的贝塞尔曲线，在干流两侧交错排布但未旋转\n        let branchBezier = genBezierByLen(branch.target, branch.setCurveLen, idx)\n        // drawLine(branchBezier.getLUT(), 2, 'green') \n\n        // 3.沿着干流，依次对各支流，绕各自的 target 点旋转，将支流摆放到合理位置\n        const msNormal = parent.bezier.normal(iValue) //干流上汇入点的法向量\n        let bNormal = branchBezier.normal(1)//支流上汇入点的法向量\n        let angle = utils.calVectorsAngle(msNormal, bNormal) //干流与初始位置的支流在汇入点的夹角\n\n        if (idx % 2 === 0) {\n            branchBezier = hangBranch(false, rightBranchesBeziers, branchBezier, branch.target, angle, minMergeAngle, stepAngle)\n        } else {\n            branchBezier = hangBranch(true, leftBranchesBeziers, branchBezier, branch.target, angle, minMergeAngle, stepAngle)\n        }\n\n        branch.setBezier(branchBezier)\n    });\n\n    // [...leftBranchesBeziers, ...rightBranchesBeziers].forEach(branchBezier => {\n    //     drawLine(branchBezier.getLUT(), 2)\n    // })\n\n    return branches\n}\n\n//---------------------工具函数--------------------\n/**\n * 玄学函数：根据 target 点和预设曲线长度生成贝塞尔曲线，注意还需要经过旋转等操作。\n * @param {Point} t \n * @param {Number} len \n * @param {Number} idx 支流的序号，以奇偶将支流交错排布在干流两侧\n */\nfunction genBezierByLen(t, len, idx) {\n    let w, h, s, sCtrl, tCtrl, bezier, i = 1\n    const d = len / sqrt2 * 0.75\n    w = d\n    if (idx % 2 !== 0) {\n        while (i < 2) {\n            h = d * i\n            i += 0.05\n            s = new Point(t.x - w, t.y + h)\n            sCtrl = new Point(s.x, s.y - h * 0.5)\n            tCtrl = new Point(t.x, t.y + h * 0.5)\n            bezier = new Bezier(s, sCtrl, tCtrl, t)\n            if (Math.abs(bezier.length() - len) < lenTolerate) {\n                break\n            }\n        }\n    } else {\n        while (i < 2) {\n            h = d * i\n            i += 0.05\n            s = new Point(t.x - w, t.y - h)\n            sCtrl = new Point(s.x, s.y + h * 0.5)\n            tCtrl = new Point(t.x, t.y - h * 0.5)\n            bezier = new Bezier(s, sCtrl, tCtrl, t)\n            if (Math.abs(bezier.length() - len) < lenTolerate) {\n                break\n            }\n        }\n    }\n\n    return bezier\n}\n\n// 缩小坐标\nfunction minimizeCoord(pt) {\n    return [pt.x * 0.01, pt.y * 0.01]\n}\n// 放大坐标\nfunction magnifyCoord(pt) {\n    return [pt[0] * 100, pt[1] * 100]\n}\n\nfunction genBezierBy4pts(s, sCtrl, tCtrl, t) {\n    s = new Point(s[0], s[1])\n    sCtrl = new Point(sCtrl[0], sCtrl[1])\n    tCtrl = new Point(tCtrl[0], tCtrl[1])\n    t = new Point(t[0], t[1])\n    bezier = new Bezier(s, sCtrl, tCtrl, t)\n    return bezier\n}\n\n/**\n * 绕一个点，旋转贝塞尔曲线。实际上是先旋转2端点和2控制点，再重新生成 Bezier 曲线\n * @param {Bezier} bezier 贝塞尔曲线对象\n * @param {Point} pivot 旋转围绕的点\n * @param {number} theta 旋转角度,顺时针为负，单位为度\n */\nfunction rotateBezier(bezier, pivot, theta) {\n    let { 0: s, 1: sCtrl, 2: tCtrl, 3: t } = bezier.points\n    s = minimizeCoord(s)\n    sCtrl = minimizeCoord(sCtrl)\n    tCtrl = minimizeCoord(tCtrl)\n    t = minimizeCoord(t)\n    pivot = minimizeCoord(pivot)\n\n    const points = turf.multiPoint([s, sCtrl, tCtrl, t]) //点的第二个坐标不能大于90\n    const rotatedPts = turf.transformRotate(points, theta, { pivot })\n        .geometry.coordinates.map(pt => magnifyCoord(pt))\n\n    const rotatedBezier = genBezierBy4pts(...rotatedPts)\n    return rotatedBezier\n}\n\n/**\n * 两条线是否相交\n * @param {Bezier | []} bezier1 \n * @param {Bezier | []} bezier2 \n */\nfunction isTwoLinesIntersect(bezier1, bezier2) {\n    let pts1, pts2\n    if (Array.isArray(bezier1)) {\n        pts1 = bezier1\n        pts2 = bezier2\n    } else {\n        pts1 = bezier1.getLUT().map(pt => [pt.x, pt.y])\n        pts2 = bezier2.getLUT().map(pt => [pt.x, pt.y])\n    }\n\n    const line1 = turf.lineString(pts1);\n    const line2 = turf.lineString(pts2);\n    return !turf.booleanDisjoint(line1, line2);\n}\n\n/**\n * 一条线与多条线进行是否相交的检测\n * @param {[Bezier] | [[]]} beziers \n * @param {Bezier | []} bezier \n */\nfunction isLinesIntersect(beziers, bezier) {\n    let intersect = false\n    for (let i = beziers.length - 1; i > -1; i--) {\n        intersect = isTwoLinesIntersect(beziers[i], bezier)\n        if (intersect) {\n            break\n        }\n    }\n    return intersect\n}\n\n/**\n * 将支流挂在干流上\n * @param {boolean} isLeft 该支流是否在干流左侧\n * @param {[]} branchesBezires 干流一侧的已经挂好的支流\n * @param {Bezier} branchBezier 代表该支流的贝塞尔曲线对象\n * @param {Point} pivot 贝塞尔曲线旋转所围绕的点\n * @param {number} angle 旋转前支流与干流在汇入点的夹角\n * @param {number} minMergeAngle 最小汇入角\n * @param {number} stepAngle 调整支流位置时每次旋转的角度\n */\nfunction hangBranch(isLeft, branchesBezires, branchBezier, pivot, angle, minMergeAngle, stepAngle) {\n    let intersect\n    // 奇数序数的支流，绕 targrt 顺时针旋转，排在干流起点到终点方向左侧\n    if (isLeft) {\n        branchBezier = rotateBezier(branchBezier, pivot, -angle / Math.PI * 180 - minMergeAngle)\n        intersect = isLinesIntersect(branchesBezires, branchBezier)\n        while (intersect) {\n            branchBezier = rotateBezier(branchBezier, pivot, -angle / Math.PI * 180 - minMergeAngle - stepAngle)\n            intersect = isLinesIntersect(branchesBezires, branchBezier)\n        }\n    } else {\n        // 偶数序数的支流，绕 targrt 逆时针旋转，排在干流起点到终点方向右侧\n        branchBezier = rotateBezier(branchBezier, pivot, angle / Math.PI * 180 + minMergeAngle)\n        intersect = isLinesIntersect(branchesBezires, branchBezier)\n        while (intersect) {\n            branchBezier = rotateBezier(branchBezier, pivot, angle / Math.PI * 180 + minMergeAngle + stepAngle)\n            intersect = isLinesIntersect(branchesBezires, branchBezier)\n        }\n    }\n\n    branchesBezires.push(branchBezier)\n    return branchBezier\n}\n\nfunction layoutOptimize(ms, branchesBezires) {\n\n}\n\nmodule.exports = { genMainStream, genBranches }","code":"'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _require = require('./River'),\n    River = _require.River;\n\nvar Point = require('./Point');\n\nvar _require2 = require('./draw'),\n    drawPt = _require2.drawPt,\n    drawLine = _require2.drawLine;\n\nvar Bezier = require('bezier-js');\nvar turf = require('@turf/turf');\n\nvar _require3 = require('./utils'),\n    utils = _require3.utils;\n\nvar sqrt2 = Math.sqrt(2);\nvar digitMatcher = /\\d+/;\n\nvar lenTolerate = 10;\nvar mbAngle = Math.PI / 3;\nvar minMergeAngle = 10;\nvar stepAngle = 5;\nfunction genMainStream(svg, padding, properties) {\n    var _svg$style = svg.style,\n        width = _svg$style.width,\n        height = _svg$style.height;\n\n    width = +width.match(digitMatcher)[0] || 960;\n    height = +height.match(digitMatcher)[0] || 600;\n\n    var source = new Point(padding, height * 0.5);\n    var target = new Point(width - padding, height * 0.5);\n    var sCtrlPt = new Point(width * 0.5, height * 0.25);\n    var tCtrlPt = new Point(width * 0.5, height * 0.75);\n\n    var ms = new River(null, source, target, properties);\n    ms.setBezierByCtrlPts(sCtrlPt, tCtrlPt);\n    ms.setCurveLen = ms.bezier.length();\n\n    return ms;\n}\n\nfunction genBranches(parent, data) {\n    var branchCount = data.length;\n\n    var branch = void 0;\n    var branches = [];\n    var leftBranchesBeziers = [];\n    var rightBranchesBeziers = [];\n\n    for (var i = 0; i < branchCount; i++) {\n        branch = new River(parent, undefined, undefined, data[i]);\n        branches.push(branch);\n    }\n\n    parent.setBranches(branches);\n\n    var branchMergePts = parent.calcBranchMergePts();\n    branches.forEach(function (branch, idx) {\n        var _branchMergePts$idx = branchMergePts[idx],\n            pt = _branchMergePts$idx.pt,\n            iValue = _branchMergePts$idx.iValue;\n\n        branch.setTarget(pt);\n        drawPt(branch.target);\n\n        var branchBezier = genBezierByLen(branch.target, branch.setCurveLen, idx);\n\n        var msNormal = parent.bezier.normal(iValue);\n        var bNormal = branchBezier.normal(1);\n        var angle = utils.calVectorsAngle(msNormal, bNormal);\n\n        if (idx % 2 === 0) {\n            branchBezier = hangBranch(false, rightBranchesBeziers, branchBezier, branch.target, angle, minMergeAngle, stepAngle);\n        } else {\n            branchBezier = hangBranch(true, leftBranchesBeziers, branchBezier, branch.target, angle, minMergeAngle, stepAngle);\n        }\n\n        branch.setBezier(branchBezier);\n    });\n\n    return branches;\n}\n\nfunction genBezierByLen(t, len, idx) {\n    var w = void 0,\n        h = void 0,\n        s = void 0,\n        sCtrl = void 0,\n        tCtrl = void 0,\n        bezier = void 0,\n        i = 1;\n    var d = len / sqrt2 * 0.75;\n    w = d;\n    if (idx % 2 !== 0) {\n        while (i < 2) {\n            h = d * i;\n            i += 0.05;\n            s = new Point(t.x - w, t.y + h);\n            sCtrl = new Point(s.x, s.y - h * 0.5);\n            tCtrl = new Point(t.x, t.y + h * 0.5);\n            bezier = new Bezier(s, sCtrl, tCtrl, t);\n            if (Math.abs(bezier.length() - len) < lenTolerate) {\n                break;\n            }\n        }\n    } else {\n        while (i < 2) {\n            h = d * i;\n            i += 0.05;\n            s = new Point(t.x - w, t.y - h);\n            sCtrl = new Point(s.x, s.y + h * 0.5);\n            tCtrl = new Point(t.x, t.y - h * 0.5);\n            bezier = new Bezier(s, sCtrl, tCtrl, t);\n            if (Math.abs(bezier.length() - len) < lenTolerate) {\n                break;\n            }\n        }\n    }\n\n    return bezier;\n}\n\nfunction minimizeCoord(pt) {\n    return [pt.x * 0.01, pt.y * 0.01];\n}\n\nfunction magnifyCoord(pt) {\n    return [pt[0] * 100, pt[1] * 100];\n}\n\nfunction genBezierBy4pts(s, sCtrl, tCtrl, t) {\n    s = new Point(s[0], s[1]);\n    sCtrl = new Point(sCtrl[0], sCtrl[1]);\n    tCtrl = new Point(tCtrl[0], tCtrl[1]);\n    t = new Point(t[0], t[1]);\n    bezier = new Bezier(s, sCtrl, tCtrl, t);\n    return bezier;\n}\n\nfunction rotateBezier(bezier, pivot, theta) {\n    var _bezier$points = bezier.points,\n        s = _bezier$points[0],\n        sCtrl = _bezier$points[1],\n        tCtrl = _bezier$points[2],\n        t = _bezier$points[3];\n\n    s = minimizeCoord(s);\n    sCtrl = minimizeCoord(sCtrl);\n    tCtrl = minimizeCoord(tCtrl);\n    t = minimizeCoord(t);\n    pivot = minimizeCoord(pivot);\n\n    var points = turf.multiPoint([s, sCtrl, tCtrl, t]);\n    var rotatedPts = turf.transformRotate(points, theta, { pivot: pivot }).geometry.coordinates.map(function (pt) {\n        return magnifyCoord(pt);\n    });\n\n    var rotatedBezier = genBezierBy4pts.apply(undefined, _toConsumableArray(rotatedPts));\n    return rotatedBezier;\n}\n\nfunction isTwoLinesIntersect(bezier1, bezier2) {\n    var pts1 = void 0,\n        pts2 = void 0;\n    if (Array.isArray(bezier1)) {\n        pts1 = bezier1;\n        pts2 = bezier2;\n    } else {\n        pts1 = bezier1.getLUT().map(function (pt) {\n            return [pt.x, pt.y];\n        });\n        pts2 = bezier2.getLUT().map(function (pt) {\n            return [pt.x, pt.y];\n        });\n    }\n\n    var line1 = turf.lineString(pts1);\n    var line2 = turf.lineString(pts2);\n    return !turf.booleanDisjoint(line1, line2);\n}\n\nfunction isLinesIntersect(beziers, bezier) {\n    var intersect = false;\n    for (var i = beziers.length - 1; i > -1; i--) {\n        intersect = isTwoLinesIntersect(beziers[i], bezier);\n        if (intersect) {\n            break;\n        }\n    }\n    return intersect;\n}\n\nfunction hangBranch(isLeft, branchesBezires, branchBezier, pivot, angle, minMergeAngle, stepAngle) {\n    var intersect = void 0;\n\n    if (isLeft) {\n        branchBezier = rotateBezier(branchBezier, pivot, -angle / Math.PI * 180 - minMergeAngle);\n        intersect = isLinesIntersect(branchesBezires, branchBezier);\n        while (intersect) {\n            branchBezier = rotateBezier(branchBezier, pivot, -angle / Math.PI * 180 - minMergeAngle - stepAngle);\n            intersect = isLinesIntersect(branchesBezires, branchBezier);\n        }\n    } else {\n        branchBezier = rotateBezier(branchBezier, pivot, angle / Math.PI * 180 + minMergeAngle);\n        intersect = isLinesIntersect(branchesBezires, branchBezier);\n        while (intersect) {\n            branchBezier = rotateBezier(branchBezier, pivot, angle / Math.PI * 180 + minMergeAngle + stepAngle);\n            intersect = isLinesIntersect(branchesBezires, branchBezier);\n        }\n    }\n\n    branchesBezires.push(branchBezier);\n    return branchBezier;\n}\n\nfunction layoutOptimize(ms, branchesBezires) {}\n\nmodule.exports = { genMainStream: genMainStream, genBranches: genBranches };","codeWraped":"Cube(\"/src/main.js\", [\"/src/River.js\", \"/src/Point.js\", \"/src/draw.js\", \"/node_modules/bezier-js/index.js\", \"/node_modules/@turf/turf/turf.min.js\", \"/src/utils.js\"], function (module, exports, require, load, process, global) {\n\n  function _toConsumableArray(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;} else {return Array.from(arr);}}\n\n  var _require = require('/src/River.js'),\n  River = _require.River;\n\n  var Point = require('/src/Point.js');\n\n  var _require2 = require('/src/draw.js'),\n  drawPt = _require2.drawPt,\n  drawLine = _require2.drawLine;\n\n  var Bezier = require('/node_modules/bezier-js/index.js');\n  var turf = require('/node_modules/@turf/turf/turf.min.js');\n\n  var _require3 = require('/src/utils.js'),\n  utils = _require3.utils;\n\n  var sqrt2 = Math.sqrt(2);\n  var digitMatcher = /\\d+/;\n\n  var lenTolerate = 10;\n  var mbAngle = Math.PI / 3;\n  var minMergeAngle = 10;\n  var stepAngle = 5;\n  function genMainStream(svg, padding, properties) {\n    var _svg$style = svg.style,\n    width = _svg$style.width,\n    height = _svg$style.height;\n\n    width = +width.match(digitMatcher)[0] || 960;\n    height = +height.match(digitMatcher)[0] || 600;\n\n    var source = new Point(padding, height * 0.5);\n    var target = new Point(width - padding, height * 0.5);\n    var sCtrlPt = new Point(width * 0.5, height * 0.25);\n    var tCtrlPt = new Point(width * 0.5, height * 0.75);\n\n    var ms = new River(null, source, target, properties);\n    ms.setBezierByCtrlPts(sCtrlPt, tCtrlPt);\n    ms.setCurveLen = ms.bezier.length();\n\n    return ms;\n  }\n\n  function genBranches(parent, data) {\n    var branchCount = data.length;\n\n    var branch = void 0;\n    var branches = [];\n    var leftBranchesBeziers = [];\n    var rightBranchesBeziers = [];\n\n    for (var i = 0; i < branchCount; i++) {\n      branch = new River(parent, undefined, undefined, data[i]);\n      branches.push(branch);\n    }\n\n    parent.setBranches(branches);\n\n    var branchMergePts = parent.calcBranchMergePts();\n    branches.forEach(function (branch, idx) {\n      var _branchMergePts$idx = branchMergePts[idx],\n      pt = _branchMergePts$idx.pt,\n      iValue = _branchMergePts$idx.iValue;\n\n      branch.setTarget(pt);\n      drawPt(branch.target);\n\n      var branchBezier = genBezierByLen(branch.target, branch.setCurveLen, idx);\n\n      var msNormal = parent.bezier.normal(iValue);\n      var bNormal = branchBezier.normal(1);\n      var angle = utils.calVectorsAngle(msNormal, bNormal);\n\n      if (idx % 2 === 0) {\n        branchBezier = hangBranch(false, rightBranchesBeziers, branchBezier, branch.target, angle, minMergeAngle, stepAngle);\n      } else {\n        branchBezier = hangBranch(true, leftBranchesBeziers, branchBezier, branch.target, angle, minMergeAngle, stepAngle);\n      }\n\n      branch.setBezier(branchBezier);\n    });\n\n    return branches;\n  }\n\n  function genBezierByLen(t, len, idx) {\n    var w = void 0,\n    h = void 0,\n    s = void 0,\n    sCtrl = void 0,\n    tCtrl = void 0,\n    bezier = void 0,\n    i = 1;\n    var d = len / sqrt2 * 0.75;\n    w = d;\n    if (idx % 2 !== 0) {\n      while (i < 2) {\n        h = d * i;\n        i += 0.05;\n        s = new Point(t.x - w, t.y + h);\n        sCtrl = new Point(s.x, s.y - h * 0.5);\n        tCtrl = new Point(t.x, t.y + h * 0.5);\n        bezier = new Bezier(s, sCtrl, tCtrl, t);\n        if (Math.abs(bezier.length() - len) < lenTolerate) {\n          break;\n        }\n      }\n    } else {\n      while (i < 2) {\n        h = d * i;\n        i += 0.05;\n        s = new Point(t.x - w, t.y - h);\n        sCtrl = new Point(s.x, s.y + h * 0.5);\n        tCtrl = new Point(t.x, t.y - h * 0.5);\n        bezier = new Bezier(s, sCtrl, tCtrl, t);\n        if (Math.abs(bezier.length() - len) < lenTolerate) {\n          break;\n        }\n      }\n    }\n\n    return bezier;\n  }\n\n  function minimizeCoord(pt) {\n    return [pt.x * 0.01, pt.y * 0.01];\n  }\n\n  function magnifyCoord(pt) {\n    return [pt[0] * 100, pt[1] * 100];\n  }\n\n  function genBezierBy4pts(s, sCtrl, tCtrl, t) {\n    s = new Point(s[0], s[1]);\n    sCtrl = new Point(sCtrl[0], sCtrl[1]);\n    tCtrl = new Point(tCtrl[0], tCtrl[1]);\n    t = new Point(t[0], t[1]);\n    bezier = new Bezier(s, sCtrl, tCtrl, t);\n    return bezier;\n  }\n\n  function rotateBezier(bezier, pivot, theta) {\n    var _bezier$points = bezier.points,\n    s = _bezier$points[0],\n    sCtrl = _bezier$points[1],\n    tCtrl = _bezier$points[2],\n    t = _bezier$points[3];\n\n    s = minimizeCoord(s);\n    sCtrl = minimizeCoord(sCtrl);\n    tCtrl = minimizeCoord(tCtrl);\n    t = minimizeCoord(t);\n    pivot = minimizeCoord(pivot);\n\n    var points = turf.multiPoint([s, sCtrl, tCtrl, t]);\n    var rotatedPts = turf.transformRotate(points, theta, { pivot: pivot }).geometry.coordinates.map(function (pt) {\n      return magnifyCoord(pt);\n    });\n\n    var rotatedBezier = genBezierBy4pts.apply(undefined, _toConsumableArray(rotatedPts));\n    return rotatedBezier;\n  }\n\n  function isTwoLinesIntersect(bezier1, bezier2) {\n    var pts1 = void 0,\n    pts2 = void 0;\n    if (Array.isArray(bezier1)) {\n      pts1 = bezier1;\n      pts2 = bezier2;\n    } else {\n      pts1 = bezier1.getLUT().map(function (pt) {\n        return [pt.x, pt.y];\n      });\n      pts2 = bezier2.getLUT().map(function (pt) {\n        return [pt.x, pt.y];\n      });\n    }\n\n    var line1 = turf.lineString(pts1);\n    var line2 = turf.lineString(pts2);\n    return !turf.booleanDisjoint(line1, line2);\n  }\n\n  function isLinesIntersect(beziers, bezier) {\n    var intersect = false;\n    for (var i = beziers.length - 1; i > -1; i--) {\n      intersect = isTwoLinesIntersect(beziers[i], bezier);\n      if (intersect) {\n        break;\n      }\n    }\n    return intersect;\n  }\n\n  function hangBranch(isLeft, branchesBezires, branchBezier, pivot, angle, minMergeAngle, stepAngle) {\n    var intersect = void 0;\n\n    if (isLeft) {\n      branchBezier = rotateBezier(branchBezier, pivot, -angle / Math.PI * 180 - minMergeAngle);\n      intersect = isLinesIntersect(branchesBezires, branchBezier);\n      while (intersect) {\n        branchBezier = rotateBezier(branchBezier, pivot, -angle / Math.PI * 180 - minMergeAngle - stepAngle);\n        intersect = isLinesIntersect(branchesBezires, branchBezier);\n      }\n    } else {\n      branchBezier = rotateBezier(branchBezier, pivot, angle / Math.PI * 180 + minMergeAngle);\n      intersect = isLinesIntersect(branchesBezires, branchBezier);\n      while (intersect) {\n        branchBezier = rotateBezier(branchBezier, pivot, angle / Math.PI * 180 + minMergeAngle + stepAngle);\n        intersect = isLinesIntersect(branchesBezires, branchBezier);\n      }\n    }\n\n    branchesBezires.push(branchBezier);\n    return branchBezier;\n  }\n\n  function layoutOptimize(ms, branchesBezires) {}\n\n  module.exports = { genMainStream: genMainStream, genBranches: genBranches };return module.exports;});","sourceMap":null,"modifyTime":1583311428346,"mime":"application/javascript","wrap":true,"skip":false,"compress":false,"ext":".js","targetExt":".js","loads":[],"originalLoads":[],"requires":["/src/River.js","/src/Point.js","/src/draw.js","/node_modules/bezier-js/index.js","/node_modules/@turf/turf/turf.min.js","/src/utils.js"],"requiresOrigin":["/src/River.js","/src/Point.js","/src/draw.js","/node_modules/bezier-js/index.js","/node_modules/@turf/turf/turf.min.js","/src/utils.js"],"debugInfo":[],"requiresArgsRefer":[{"type":"StringLiteral","start":235,"end":244,"loc":{"start":{"line":5,"column":23},"end":{"line":5,"column":32}},"extra":{"rawValue":"./River","raw":"'./River'"},"value":"/src/River.js"},{"type":"StringLiteral","start":296,"end":305,"loc":{"start":{"line":8,"column":20},"end":{"line":8,"column":29}},"extra":{"rawValue":"./Point","raw":"'./Point'"},"value":"/src/Point.js"},{"type":"StringLiteral","start":333,"end":341,"loc":{"start":{"line":10,"column":24},"end":{"line":10,"column":32}},"extra":{"rawValue":"./draw","raw":"'./draw'"},"value":"/src/draw.js"},{"type":"StringLiteral","start":432,"end":443,"loc":{"start":{"line":14,"column":21},"end":{"line":14,"column":32}},"extra":{"rawValue":"bezier-js","raw":"'bezier-js'"},"value":"/node_modules/bezier-js/index.js"},{"type":"StringLiteral","start":465,"end":477,"loc":{"start":{"line":15,"column":19},"end":{"line":15,"column":31}},"extra":{"rawValue":"@turf/turf","raw":"'@turf/turf'"},"value":"/node_modules/@turf/turf/turf.min.js"},{"type":"StringLiteral","start":505,"end":514,"loc":{"start":{"line":17,"column":24},"end":{"line":17,"column":33}},"extra":{"rawValue":"./utils","raw":"'./utils'"},"value":"/src/utils.js"}]}